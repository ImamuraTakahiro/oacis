==========================================
高度な使い方
==========================================

スケジューラを経由してジョブを実行する
==========================================

| ジョブスケジューラー（Torqueなど）を経由してジョブを実行する方法について説明する。
| Host登録時にジョブスケジューラを指定する事にって、スケジューラのジョブ投入コマンド経由でジョブが実行されるようになる。
| 現在サポートされているスケジューラはTorqueとPJM(Fujitsu FX10で採用されているジョブスケジューラ)のみである。
| 以降ではTorqueにジョブを投げるケースを想定して説明する。

スクリプトのヘッダに特別な指定がいらないケース
----------------------------------------------

| シングルスレッド、シングルプロセスのジョブでスクリプトのヘッダに特別な記述が必要ない場合は、Hostの登録時にスケジューラタイプとして *Torque* を選択するだけでよい。
| このようにセットしておけば、workerがジョブスクリプトをqsubコマンドで実行し、その際に取得したTorqueのジョブIDを記録する。
| workerは定期的に qstat コマンドで得られた結果をパースしてジョブの状態をモニターし、ジョブの完了後に計算結果を取得する。
| 実行中に異常終了した場合、途中までの結果をサーバーにダウンロードしRunのステータスを *failed* として記録する。
| 実行中にユーザーによってRunが削除された場合は、qdelコマンドを使用してジョブを停止させる。

| PJMの場合には pjsub, pjstat, pjdel コマンドを使用してジョブの管理を行う。

スクリプトのヘッダに変数を指定するケース
----------------------------------------------

| スクリプトのヘッダにスケジューラのパラメータ（使用時間、占有するノード数、使用メモリ量など）を指定する必要があるケースについて説明する。
| ここでは例としてMPIで並列化しているシミュレーターを、Torqueのスケジューラを使って占有時間を指定して実行することを考える。

| スクリプトのヘッダに指定する変数は以下のようになる。
.. code-block:: sh

  #!/bin/bash
  #PBS -l nodes=2:ppn=4
  #PBS -l walltime=10:00
  ...

| ここでnodesが使用するノード数、ppnは各ノード内のプロセス数、walltimeが実行制限時間である。
| 各ジョブによってこれらの値が異なるため、Runの作成時にこれらの値を指定できるようにしたい。

| そのためにはホストパラメータと呼ぶ仕組みを使用する。
| ホストパラメータとして指定した変数は各Runの作成時に個別に入力することができ、その変数がホストのテンプレート部分に展開される。

| 具体的には以下の手順でHostの "template", "Definition of Host Parameters" というフィールドを設定する。
1. templateの変数展開をしたい部分を *<%= ... %>* という記号で囲む。今回の例ではヘッダ部分を以下のように編集する。
  .. code-block:: sh

    #!/bin/bash
    #PBS -l nodes=<%= nodes %>:ppn=<%= ppn %>
    #PBS -l walltime=<%= walltime %>
    ...

2. "Definition of Host Parameter"の部分に展開したい変数の変数名、デフォルト値、フォーマット（入力可能な形式を正規表現で指定）を入力する。
  今回の場合、以下のように設定する。（formatの部分は空でもよいが、設定しておくとRunの作成時に不正な値を入れるとエラーになるのでミスに気づきやすくなる。）

  * Name: nodes,    Default: 1, format: ^\d+$
  * Name: ppn,      Default: 1, format: ^\d+$
  * Name: walltime, Default: 10:00, format: ^(\d\d:)?\d\d:\d\d$

  .. image:: images/edit_host_template.png
    :width: 50%
    :align: center

  | この際、テンプレートとホストパラメータ定義が整合していないとエラーとなる。
  | テンプレートで展開する変数は必ずホストパラメータとして定義されている必要があり、ホストパラメータとして定義された変数はテンプレート中に現れなくてはならない。

| 以上でホストの設定は完了である。
| この設定後、Runの作成時に以下のようにホストパラメータを入力する箇所が現れる。
| 適切な値を入れて [Preview] ボタンをクリックするとジョブスクリプトのプレビューが表示される。
| [Create Run]をクリックするとRunが作成され、順番にジョブが投入される。

.. image:: images/new_run_with_host_params.png
  :width: 30%
  :align: center

MPI, OpenMPのジョブ
-------------------------------------------------------------

| MPI, OpenMPで並列化されたシミュレーターの場合、実行時にMPIのプロセス数、OpenMPのスレッド数を指定することが必要となる。
| Simulator登録時に、 *Suppot MPI*, *Support OMP* のチェックを入れると、Runの作成時にプロセス数とスレッド数を指定するフィールドが表示されるようになる。

.. image:: images/new_run_mpi_omp_support.png
  :width: 30%
  :align: center

| ここで指定したプロセス数・スレッド数はテンプレートの中でそれぞれ *<%= mpi_procs %>*, *<%= omp_threads %>* という変数に展開される。
| Hostのテンプレートを確認すれば分かるとおり、OpenMPのスレッド数はスクリプトの中で環境変数 *OMP_NUM_THREADS* に代入される。
| 同様にMPIのプロセス数は、mpiexec コマンドの -n オプションの引数に展開される。
| これによりシミュレーターが指定したプロセス数・スレッド数で実行されるようにしている。

| つまりOpenMPで並列化しているシミュレーターはOMP_NUM_THREADS環境変数を参照してスレッド数を決めるように実装されていなければならない。
| （ プログラム内で *omp_set_num_threads()* 関数で別途指定している場合は、当然ながらここで指定したスレッド数は適用されない）

| MPIで並列化している場合、プロセス数は *mpiexec* コマンドの引数で渡されるが、 *mpiexec* コマンド以外のMPIプロセス実行コマンドを指定したい場合はHostのテンプレートを編集すればよい。

| スクリプトのヘッダ部分でも <%= mpi_procs %>, <%= omp_threads %> 変数を展開することができる。
| これを利用するとMPIプロセス数に応じて確保するノード数を自動的に決めたりすることができる。
| 例として、Flat MPIのプログラムを、１ノードあたり８コアのマシンで実行することを考える。
| Hostのテンプレートに以下のように書くことで、ノード数が自動的に指定されるようになる。（ただし、プロセス数は８の倍数にする必要がある）

.. code-block:: sh

  #!/bin/bash
  #PBS -l nodes=<%= mpi_procs / 8 %>:ppn=8
  #PBS -l walltime=10:00
  ...

プリプロセスの定義
==============================================

| シミュレーターによっては実際にシミュレーションジョブを開始する前に、入力ファイルを準備したりフォーマットを調整したりするプリプロセスが必要な場合がしばしばある。
| しかしプリプロセスを計算ジョブの中で行おうとすると以下のようなケースで問題になる。

  * スクリプト言語など入力ファイルの準備に使うプログラムが計算ノードにインストールされていないケース
  * 外部へのネットワークが遮断され入力用ファイルを準備するために外部からファイルを転送することができないケース
  * ファイルのステージングの都合により、ジョブの実行前にファイルをすべて用意する必要があるケース

| そこで、CMにはジョブの実行前にプリプロセスを個別に実行する仕組みを用意してある。
| このプリプロセスはジョブの投入前にログインノードで実行されるため上記の問題は起きない。
| ここではプリプロセスの仕様と設定方法を説明する。

| プリプロセスはジョブの投入前にworkerによってssh経由で実行される。
| workerの実行手順は

  1. 各Runごとにワークディレクトリを作成する
  2. SimulatorがJSON入力の場合、_input.jsonを配置する。
  3. Simulatorの *pre_process_script* フィールドに記載されたスクリプトをワークディレクトリに配置し実行権限をつける。(_preprocess.sh というファイル名で配置される)
  4. _preprocess.sh をワークディレクトリをカレントディレクトリとして実行する。
    * この際Simulatorが引数形式ならば、同様の引数を与えて _preprocess.sh を実行する。この引数から実行パラメータを取得することができる。
    * 標準出力、標準エラー出力は _stdout.txt, _stderr.txt にそれぞれリダイレクトされる。
  5. _preprocess.sh のリターンコードがノンゼロの場合には、SSHのセッションを切断しRunをfailedとする。
    * failedの時には、ワークディレクトリの内容をサーバーにコピーし、リモートサーバー上のファイルは削除する。
  6. _preprocess.sh を削除する
  7. シミュレーションジョブをサブミットする。

| ただし、 Simulatorの pre_process_script のフィールドが空の場合には、上記3~6の手順は実行されない。

Analyzerの登録と実行
==============================================
